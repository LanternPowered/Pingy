plugins {
    id "com.github.hierynomus.license" version "0.13.1"
    // id "com.github.johnrengelman.shadow" version "1.2.3"
}

apply plugin: 'java'
apply plugin: 'eclipse'
apply plugin: 'idea'
apply plugin: 'com.github.johnrengelman.shadow'
apply plugin: 'com.github.hierynomus.license'

sourceCompatibility = '1.8'
targetCompatibility = '1.8'

group = 'org.lanterpowered'
archivesBaseName = project.name.toLowerCase()
version = '1.0.0-SNAPSHOT'

ext.runFolder = 'run'
ext.mainClass = 'org.lanternpowered.pingy.Pingy'

repositories {
	mavenCentral()
}

configurations {
    netty
    compile {
        extendsFrom netty
    }
}

dependencies {
    compile group: 'com.google.code.gson', name: 'gson', version: '2.6.2'
    netty group: 'io.netty', name: 'netty-all', version: '4.0.21.Final'
}

// Create the run folder
task createRunFolder {
    if (!project.file(runFolder).exists()) {
        project.file(runFolder).mkdirs()
    }
}

tasks.eclipse.dependsOn createRunFolder
tasks.idea.dependsOn createRunFolder

// Generate application setups, currently only for intellij
idea.workspace.iws.withXml { provider ->
    // The app name
    def appName = 'Pingy Server'

    // Get the run manager node, this will contain the configuration
    def node = provider.asNode().component.find { it.@name == 'RunManager' }

    // Find the default and custom app node
    def defaultNode = node.find { it.@type == 'Application' && it.@default == 'true' }
    def customNode = node.find { it.@type == 'Application' && it.@name == appName }

    // It should always be present
    if (defaultNode == null) {
        throw new IllegalStateException('Unable to find the default application config node,' +
                ' please try to regenerate the intellij project files to resolve this issue.')
    }

    // Only create a new configuration if the old one is missing
    if (customNode == null) {
        customNode = defaultNode.clone()
        customNode.@default = 'false'
        customNode.@name = appName
        customNode.each {
            if (it.name() == 'option' && it.@name != null) {
                switch (it.@name) {
                    case 'MAIN_CLASS_NAME':   it.@value = mainClass;                           break
                    case 'WORKING_DIRECTORY': it.@value = 'file://$PROJECT_DIR$/' + runFolder; break
                }
            } else if (it.name() == 'module') {
                it.@name = project.name
            }
        }
        node.append customNode
    }
}

jar {
    classifier = 'base'
    manifest {
        attributes(
                'Main-Class': mainClass
        )
    }
}

processResources {
    from 'LICENSE.txt'
}

import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar
import org.lanternpowered.gradle.transformer.DependencyClassTransformer

// A separate task to generate the netty jar,
// doing this separate to avoid long wait times
// Run "nettyJar" to update the jar
task nettyJar(type: ShadowJar) {
    // The classifier
    classifier = 'netty'
    // Exclude empty directories
    includeEmptyDirs = false
    // Include all the netty classes into the process
    from zipTree(project.configurations.netty.first())
    // Include all the project files to check
    from sourceSets.main.output

    // Loop through the files and check for the files which
    // should be included in the final jar
    transform(DependencyClassTransformer) {
        // Check only the netty path for dependencies
        dependencyFiles.include 'io/netty/**'
        // Just scan all the pingy files
        filesToScan.include 'org/lanternpowered/pingy/**'
    }
}

// Sadly enough does the "overwrite: true" parameter not work,
// so this task will delete the jar before running nettyJar
task deleteNettyJar(type: Delete) {
    delete project.nettyJar.archivePath
}
nettyJar.dependsOn deleteNettyJar

shadowJar {
    // The netty jar should be generated if missing,
    // regeneration after changes require manual triggering
    if (!project.nettyJar.archivePath.exists()) {
        dependsOn nettyJar
    }

    // Empty classifier, this is the final jar
    classifier = ''
    // Exclude empty directories
    includeEmptyDirs = false

    // Make sure that the jar is generated
    afterEvaluate {
        // Include the netty classes
        from zipTree(project.nettyJar.archivePath)
    }

    dependencies {
        include dependency('com.google.code.gson:gson')
    }

    exclude 'LICENSE', 'NOTICE'
}
assemble.dependsOn shadowJar

license {
    header rootProject.file('HEADER.txt')
    sourceSets = project.sourceSets
    include '**/*.java'

    strictCheck true
    ignoreFailures = false

    ext {
        name = project.name
        url = project.url
        organization = project.organization
    }

    mapping {
        java = 'SLASHSTAR_STYLE'
    }
}

// Gradle version used for generating the Gradle wrapper
task wrapper(type: Wrapper) {
    gradleVersion = '2.13'
}
